<!-- HTML header for doxygen 1.9.2-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>proxsuite: ProxQP solve function without API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/SVG"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
    <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
    <script type="text/javascript">
        DoxygenAwesomeDarkModeToggle.init()
    </script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">proxsuite<span id="projectnumber">&#160;0.0.0</span>
   </div>
   <div id="projectbrief">The proximal solver suite</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_doc_3_ProxQP_solve.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">ProxQP solve function without API </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p >ProxQP solves convex quadratic programs, which consists in minimizing a convex quadratic cost under some linear constraints. It is mathematically described as:</p>
<p >$$\begin{equation}\label{eq:QP}\tag{QP} \begin{aligned} \min_{x\in\mathbb{R}^{d}} &amp; \quad \frac{1}{2}x^{T}Hx+g^{T}x \\ \text{s.t.}&amp;\left\{ \begin{array}{ll} Ax = b, \\ Cx \leq u. \\ \end{array} \right. \end{aligned} \end{equation}\\ \text{with } H\in\mathbb{R}^{d\times d}, A\in\mathbb{R}^{n_\text{eq}\times d}, C\in\mathbb{R}^{n_\text{in}\times d}, b\in\mathbb{R}^{n_\text{eq}}, u\in\mathbb{R}^{n_\text{in}}. $$ H is a real symmetric positive semi-definite matrix. d is the problem dimension (i.e., the number of primal variables), while n_eq and n_in are the numbers of equality and inequality constraints respectively.</p>
<p >For linearly constrained convex optimization problems such as \eqref{eq:QP}, strong duality holds and the associated KKT conditions are necessary and sufficient for ensuring a primal-dual point (x,y,z) to be optimal (see, e.g.,<a href="https://web.stanford.edu/~boyd/cvxbook/">Section 5.2.3</a>} and <a href="https://web.stanford.edu/~boyd/papers/pdf/osqp.pdf">Section 2, page 5</a> for more details). For \eqref{eq:QP}, the KKT system is given by the set of equations:</p>
<p >$$\begin{equation}\label{qp:kkt}\tag{KKT} \begin{aligned} &amp;\left\{ \begin{array}{ll} Hx+g+A^Ty+C^Tz = 0, \\ Ax-b = 0, \\ Cx \leq u, \\ z\odot[Cx-u] = 0,\\ \end{array} \right. \end{aligned} \end{equation}$$</p>
<p >where the last equation involves the Hadamard product (i.e., for two vectors u and v, the Hadamard product is the vector whose ith entry is u_i v_i).</p>
<p >In practice, we look for a triplet (x,y,z) satisfying these optimality conditions \eqref{qp:kkt} up to a certain level of absolute accuracy (dependent of the application), leading us to the following natural absolute stopping criterion:</p>
<p >$$\begin{equation}\label{eq:approx_qp_sol} \begin{aligned} &amp;\left\{ \begin{array}{ll} |Hx+g+A^Ty+C^Tz|_{\infty} \leq \epsilon_{abs}, \\ |Ax-b|_{\infty} \leq \epsilon_{abs}, \\ |[Cx-u]_+|_{\infty}\leq \epsilon_{abs}. \\ \end{array} \right. \end{aligned} \end{equation}$$</p>
<p >The infite norm is preferred to the L2 norm as it is independent of the problem dimensions. It is also common to consider relative convergence criteria for early-stopping, as absolute targets might not bet reached due to numerical issues. ProxQP provides it in a similar way as OSQP (for more details see, e.g., <a href="https://web.stanford.edu/~boyd/papers/pdf/osqp.pdf">section 3.4</a>). Hence more generally the following stopping criterion can be used.</p>
<p >$$\begin{equation}\label{eq:approx_qp_sol_relative_criterion} \begin{aligned} &amp;\left\{ \begin{array}{ll} |Hx+g+A^Ty+C^Tz|_{\infty} \leq \epsilon_{\text{abs}} + \epsilon_{\text{rel}}\max(|Hx|_{\infty},|A^Ty|_{\infty},|C^Tz|_{\infty},|g|_{\infty}), \\ |Ax-b|_{\infty} \leq \epsilon_{\text{abs}} +\epsilon_{\text{rel}}\max(|Ax|_{\infty},|b|_{\infty}), \\ |[Cx-u]_+|_{\infty}\leq \epsilon_{\text{abs}} +\epsilon_{\text{rel}}\max(|Cx|_{\infty},|u|_{\infty}). \\ \end{array} \right. \end{aligned} \end{equation}$$</p>
<h1><a class="anchor" id="OverviewAsingleSolveFunction"></a>
A single solve function for dense and sparse backends</h1>
<p >If if you don't want to pass through <a class="el" href="2-ProxQP__api_8md.html">ProxQP API</a>, it is also possible to use one single solve function. We will show how to do so with examples.</p>
<p >You just need to call a "solve" function with in entry the model of the convex QP you want to solve. We show you below examples in C++ and python for ProxQP sparse and dense backends.</p>
<table class="manual">
<tr>
<th>examples/cpp/solve_without_api.cpp </th><th>examples/python/solve_without_api.py  </th></tr>
<tr>
<td valign="top"><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="sparse_8hpp.html">proxsuite/proxqp/sparse/sparse.hpp</a>&quot;</span> <span class="comment">// get the sparse backend of ProxQP</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="dense_8hpp.html">proxsuite/proxqp/dense/dense.hpp</a>&quot;</span>   <span class="comment">// get the dense backend of ProxQP</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="random__qp__problems_8hpp.html">proxsuite/proxqp/utils/random_qp_problems.hpp</a>&gt;</span><span class="comment">// used for generating a random convex Qp</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespaceproxsuite_1_1proxqp.html">proxsuite::proxqp</a>;</div>
<div class="line"><span class="keyword">using</span> T = double;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span></div>
<div class="line">main()</div>
<div class="line">{</div>
<div class="line">  <a class="code hl_typedef" href="namespaceproxsuite_1_1linalg_1_1veg.html#ac1e2ec3344d2681c2b7e156325cae45f">isize</a> n = 10;</div>
<div class="line">  <a class="code hl_typedef" href="namespaceproxsuite_1_1linalg_1_1veg.html#ac1e2ec3344d2681c2b7e156325cae45f">isize</a> n_eq(n / 4);</div>
<div class="line">  <a class="code hl_typedef" href="namespaceproxsuite_1_1linalg_1_1veg.html#ac1e2ec3344d2681c2b7e156325cae45f">isize</a> n_in(n / 4);</div>
<div class="line">  T p = 0.15;            <span class="comment">// level of sparsity</span></div>
<div class="line">  T conditioning = 10.0; <span class="comment">// conditioning level for H</span></div>
<div class="line">  <span class="keyword">auto</span> H = <a class="code hl_function" href="namespaceproxsuite_1_1proxqp_1_1utils_1_1rand.html#abb33f5598086a662df743b7989c7c9bb">utils::rand::sparse_positive_definite_rand</a>(n, conditioning, p);</div>
<div class="line">  <span class="keyword">auto</span> g = utils::rand::vector_rand&lt;T&gt;(n);</div>
<div class="line">  <span class="keyword">auto</span> A = utils::rand::sparse_matrix_rand&lt;T&gt;(n_eq, n, p);</div>
<div class="line">  <span class="keyword">auto</span> C = utils::rand::sparse_matrix_rand&lt;T&gt;(n_in, n, p);</div>
<div class="line">  <span class="keyword">auto</span> x_sol = utils::rand::vector_rand&lt;T&gt;(n);</div>
<div class="line">  <span class="keyword">auto</span> b = (A * x_sol).eval();</div>
<div class="line">  <span class="keyword">auto</span> l = (C * x_sol).eval();</div>
<div class="line">  <span class="keyword">auto</span> u = (l.array() + 10).matrix().eval();</div>
<div class="line">  <span class="comment">// Solve the problem using the sparse backend</span></div>
<div class="line">  Results&lt;T&gt; results_sparse_solver =</div>
<div class="line">    sparse::solve&lt;T, isize&gt;(H, g, A, b, C, u, l);</div>
<div class="line">  <span class="comment">// Solve the problem using the dense backend</span></div>
<div class="line">  Results&lt;T&gt; results_dense_solver = dense::solve&lt;T&gt;(H, g, A, b, C, u, l);</div>
<div class="line">}</div>
<div class="ttc" id="adense_8hpp_html"><div class="ttname"><a href="dense_8hpp.html">dense.hpp</a></div></div>
<div class="ttc" id="anamespaceproxsuite_1_1linalg_1_1veg_html_ac1e2ec3344d2681c2b7e156325cae45f"><div class="ttname"><a href="namespaceproxsuite_1_1linalg_1_1veg.html#ac1e2ec3344d2681c2b7e156325cae45f">proxsuite::linalg::veg::isize</a></div><div class="ttdeci">_detail::_meta::make_signed&lt; usize &gt;::Type isize</div><div class="ttdef"><b>Definition:</b> <a href="typedefs_8hpp_source.html#l00043">typedefs.hpp:43</a></div></div>
<div class="ttc" id="anamespaceproxsuite_1_1proxqp_1_1utils_1_1rand_html_abb33f5598086a662df743b7989c7c9bb"><div class="ttname"><a href="namespaceproxsuite_1_1proxqp_1_1utils_1_1rand.html#abb33f5598086a662df743b7989c7c9bb">proxsuite::proxqp::utils::rand::sparse_positive_definite_rand</a></div><div class="ttdeci">auto sparse_positive_definite_rand(isize n, Scalar cond, double p) -&gt; SparseMat&lt; Scalar &gt;</div><div class="ttdef"><b>Definition:</b> <a href="random__qp__problems_8hpp_source.html#l00192">random_qp_problems.hpp:192</a></div></div>
<div class="ttc" id="anamespaceproxsuite_1_1proxqp_html"><div class="ttname"><a href="namespaceproxsuite_1_1proxqp.html">proxsuite::proxqp</a></div><div class="ttdef"><b>Definition:</b> <a href="dense_2fwd_8hpp_source.html#l00011">fwd.hpp:11</a></div></div>
<div class="ttc" id="arandom__qp__problems_8hpp_html"><div class="ttname"><a href="random__qp__problems_8hpp.html">random_qp_problems.hpp</a></div></div>
<div class="ttc" id="asparse_8hpp_html"><div class="ttname"><a href="sparse_8hpp.html">sparse.hpp</a></div></div>
</div><!-- fragment -->  </td><td valign="top"><div class="fragment"><div class="line"><span class="keyword">import</span> proxsuite_pywrap <span class="keyword">as</span> proxsuite</div>
<div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div>
<div class="line"><span class="keyword">import</span> scipy.sparse <span class="keyword">as</span> spa</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">def </span>generate_mixed_qp(n, seed=1):</div>
<div class="line">    <span class="comment"># A function for generating random convex Qps</span></div>
<div class="line"> </div>
<div class="line">    np.random.seed(seed)</div>
<div class="line">    n_eq = int(n / 4)</div>
<div class="line">    n_in = int(n / 4)</div>
<div class="line">    m = n_eq + n_in</div>
<div class="line"> </div>
<div class="line">    P = spa.random(</div>
<div class="line">        n, n, density=0.075, data_rvs=np.random.randn, format=<span class="stringliteral">&quot;csc&quot;</span></div>
<div class="line">    ).toarray()</div>
<div class="line">    P = (P + P.T) / 2.0</div>
<div class="line"> </div>
<div class="line">    s = max(np.absolute(np.linalg.eigvals(P)))</div>
<div class="line">    P += (abs(s) + 1e-02) * spa.eye(n)</div>
<div class="line">    P = spa.coo_matrix(P)</div>
<div class="line">    q = np.random.randn(n)</div>
<div class="line">    A = spa.random(m, n, density=0.15, data_rvs=np.random.randn, format=<span class="stringliteral">&quot;csc&quot;</span>)</div>
<div class="line">    v = np.random.randn(n)  <span class="comment"># Fictitious solution</span></div>
<div class="line">    delta = np.random.rand(m)  <span class="comment"># To get inequality</span></div>
<div class="line">    u = A @ v</div>
<div class="line">    l = -1.0e20 * np.ones(m)</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> P, q, A[:n_eq, :], u[:n_eq], A[n_in:, :], u[n_in:], l[n_in:]</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment"># load a Qp object using Qp problem dimensions</span></div>
<div class="line">n = 10</div>
<div class="line">n_eq = 2</div>
<div class="line">n_in = 2</div>
<div class="line">H, g, A, b, C, u, l = generate_mixed_qp(n)</div>
<div class="line"><span class="comment"># solve the problem using the sparse backend</span></div>
<div class="line">results = proxsuite.qp.sparse.solve(H, g, A, b, C, u, l)</div>
<div class="line"><span class="comment"># solve the problem using the dense backend</span></div>
<div class="line">results2 = proxsuite.qp.dense.solve(H, g, A, b, C, u, l)</div>
</div><!-- fragment -->   </td></tr>
</table>
<p >The results of the solve call are available in the result object, which structure is described in <a class="el" href="2-ProxQP__api_8md.html">ProxQP API with examples</a> section (at "The results subclass" subsection).</p>
<p >Different options are available for the solve function. In the table below you have the list of the different parameters that can be specified in the solve function (without the model of the problem to solve). We precise from left to right their name, their default value, and a short description of it.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Option   </th><th class="markdownTableHeadNone">Default value   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">x   </td><td class="markdownTableBodyNone">Value of the EQUALITY_CONSTRAINED_INITIAL_GUESS   </td><td class="markdownTableBodyNone">Warm start value for the primal variable.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">y   </td><td class="markdownTableBodyNone">Value of the EQUALITY_CONSTRAINED_INITIAL_GUESS   </td><td class="markdownTableBodyNone">Warm start value for the dual Lagrange multiplier for equality constraints.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">z   </td><td class="markdownTableBodyNone">0   </td><td class="markdownTableBodyNone">Warm start value for the dual Lagrange multiplier for inequality constraints.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">eps_abs   </td><td class="markdownTableBodyNone">1.E-3   </td><td class="markdownTableBodyNone">Asbolute stopping criterion of the solver.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">eps_rel   </td><td class="markdownTableBodyNone">0   </td><td class="markdownTableBodyNone">Relative stopping criterion of the solver.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">mu_eq   </td><td class="markdownTableBodyNone">1.E-3   </td><td class="markdownTableBodyNone">Proximal step size wrt equality constraints multiplier.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">mu_in   </td><td class="markdownTableBodyNone">1.E-1   </td><td class="markdownTableBodyNone">Proximal step size wrt inequality constraints multiplier.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">rho   </td><td class="markdownTableBodyNone">1.E-6   </td><td class="markdownTableBodyNone">Proximal step size wrt primal variable.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">VERBOSE   </td><td class="markdownTableBodyNone">False   </td><td class="markdownTableBodyNone">If set to true, the solver prints information at each loop.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">compute_preconditioner   </td><td class="markdownTableBodyNone">True   </td><td class="markdownTableBodyNone">If set to true, the preconditioner will be derived.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">compute_timings   </td><td class="markdownTableBodyNone">True   </td><td class="markdownTableBodyNone">If set to true, timings will be computed by the solver (setup time, solving time, and run time = setup time + solving time).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">max_iter   </td><td class="markdownTableBodyNone">1.E4   </td><td class="markdownTableBodyNone">Maximal number of authorized outer iterations.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">initial_guess   </td><td class="markdownTableBodyNone">EQUALITY_CONSTRAINED_INITIAL_GUESS   </td><td class="markdownTableBodyNone">Sets the initial guess option for initilizing x, y and z.   </td></tr>
</table>
<p >All other settings are set to their default values detailed in <a class="el" href="2-ProxQP__api_8md.html">ProxQP API with examples</a> differents subsections of "The settings subclass" section.</p>
<p >Note that contrary to ProxQP API, the default value of the initial guess is the "EQUALITY_CONSTRAINED_INITIAL_GUESS" option. Indeed, there is no meaning in using the "WARM_START_WITH_PREVIOUS_RESULT" option as after the solve call, it is not possible to warm start any Qp object with previous results. Hence, the only meaningful initial guess options are:</p><ul>
<li>EQUALITY_CONSTRAINED_INITIAL_GUESS,</li>
<li>NO_INITIAL_GUESS,</li>
<li>or a WARM_START explicitly provided by the user.</li>
</ul>
<p >For the latter case, It is not necessary to specify the WARM_START initial guess in the solve function. It is sufficient to just add the warm start x, y and z in the solve function, and the solver will automatically make the setting change internally.</p>
<p >Finally, note that in C++, if you want to change one option, the order described above in the table matter. Any intermediary option not changed must be let to the std::nullopt value. In Python, you can just specify the name of the option you want to change in any order. We give an example below.</p>
<table class="manual">
<tr>
<th>examples/cpp/solve_without_api_and_option.cpp </th><th>examples/python/solve_without_api_and_option.py  </th></tr>
<tr>
<td valign="top"><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse_8hpp.html">proxsuite/proxqp/sparse/sparse.hpp</a>&gt;</span> <span class="comment">// get the sparse backend of ProxQP</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dense_8hpp.html">proxsuite/proxqp/dense/dense.hpp</a>&gt;</span>   <span class="comment">// get the dense backend of ProxQP</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="random__qp__problems_8hpp.html">proxsuite/proxqp/utils/random_qp_problems.hpp</a>&gt;</span><span class="comment">// used for generating a random convex Qp</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespaceproxsuite_1_1proxqp.html">proxsuite::proxqp</a>;</div>
<div class="line"><span class="keyword">using</span> T = double;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span></div>
<div class="line">main()</div>
<div class="line">{</div>
<div class="line">  <a class="code hl_typedef" href="namespaceproxsuite_1_1linalg_1_1veg.html#ac1e2ec3344d2681c2b7e156325cae45f">isize</a> n = 10;</div>
<div class="line">  <a class="code hl_typedef" href="namespaceproxsuite_1_1linalg_1_1veg.html#ac1e2ec3344d2681c2b7e156325cae45f">isize</a> n_eq(n / 4);</div>
<div class="line">  <a class="code hl_typedef" href="namespaceproxsuite_1_1linalg_1_1veg.html#ac1e2ec3344d2681c2b7e156325cae45f">isize</a> n_in(n / 4);</div>
<div class="line"> </div>
<div class="line">  T p = 0.15;            <span class="comment">// level of sparsity</span></div>
<div class="line">  T conditioning = 10.0; <span class="comment">// conditioning level for H</span></div>
<div class="line">  <span class="keyword">auto</span> H = <a class="code hl_function" href="namespaceproxsuite_1_1proxqp_1_1utils_1_1rand.html#abb33f5598086a662df743b7989c7c9bb">::proxsuite::proxqp::utils::rand::sparse_positive_definite_rand</a>(</div>
<div class="line">    n, conditioning, p);</div>
<div class="line">  <span class="keyword">auto</span> g = ::proxsuite::proxqp::utils::rand::vector_rand&lt;T&gt;(n);</div>
<div class="line">  <span class="keyword">auto</span> A = ::proxsuite::proxqp::utils::rand::sparse_matrix_rand&lt;T&gt;(n_eq, n, p);</div>
<div class="line">  <span class="keyword">auto</span> C = ::proxsuite::proxqp::utils::rand::sparse_matrix_rand&lt;T&gt;(n_in, n, p);</div>
<div class="line">  <span class="keyword">auto</span> x_sol = ::proxsuite::proxqp::utils::rand::vector_rand&lt;T&gt;(n);</div>
<div class="line">  <span class="keyword">auto</span> b = A * x_sol;</div>
<div class="line">  <span class="keyword">auto</span> l = C * x_sol;</div>
<div class="line">  <span class="keyword">auto</span> u = (l.array() + 10).matrix().eval();</div>
<div class="line">  <span class="comment">// Solve the problem using the dense backend</span></div>
<div class="line">  <span class="comment">// and suppose you want to change the accuracy to 1.E-9 and rho initial value</span></div>
<div class="line">  <span class="comment">// to 1.E-7</span></div>
<div class="line">  <a class="code hl_struct" href="structproxsuite_1_1proxqp_1_1Results.html">proxsuite::proxqp::Results&lt;T&gt;</a> results =</div>
<div class="line">    proxsuite::proxqp::dense::solve&lt;T&gt;(H,</div>
<div class="line">                                       g,</div>
<div class="line">                                       A,</div>
<div class="line">                                       b,</div>
<div class="line">                                       C,</div>
<div class="line">                                       u,</div>
<div class="line">                                       l,</div>
<div class="line">                                       std::nullopt,</div>
<div class="line">                                       std::nullopt,</div>
<div class="line">                                       std::nullopt,</div>
<div class="line">                                       T(1.E-9),</div>
<div class="line">                                       std::nullopt,</div>
<div class="line">                                       std::nullopt,</div>
<div class="line">                                       std::nullopt,</div>
<div class="line">                                       T(1.E-7));</div>
<div class="line">}</div>
<div class="ttc" id="astructproxsuite_1_1proxqp_1_1Results_html"><div class="ttname"><a href="structproxsuite_1_1proxqp_1_1Results.html">proxsuite::proxqp::Results</a></div><div class="ttdoc">This class stores all the results of PROXQP solvers with sparse and dense backends.</div><div class="ttdef"><b>Definition:</b> <a href="results_8hpp_source.html#l00059">results.hpp:60</a></div></div>
</div><!-- fragment -->  </td><td valign="top"><div class="fragment"><div class="line"><span class="keyword">import</span> proxsuite_pywrap <span class="keyword">as</span> proxsuite</div>
<div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div>
<div class="line"><span class="keyword">import</span> scipy.sparse <span class="keyword">as</span> spa</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">def </span>generate_mixed_qp(n, seed=1):</div>
<div class="line">    <span class="comment"># A function for generating random convex Qps</span></div>
<div class="line"> </div>
<div class="line">    np.random.seed(seed)</div>
<div class="line">    n_eq = int(n / 4)</div>
<div class="line">    n_in = int(n / 4)</div>
<div class="line">    m = n_eq + n_in</div>
<div class="line"> </div>
<div class="line">    P = spa.random(</div>
<div class="line">        n, n, density=0.075, data_rvs=np.random.randn, format=<span class="stringliteral">&quot;csc&quot;</span></div>
<div class="line">    ).toarray()</div>
<div class="line">    P = (P + P.T) / 2.0</div>
<div class="line"> </div>
<div class="line">    s = max(np.absolute(np.linalg.eigvals(P)))</div>
<div class="line">    P += (abs(s) + 1e-02) * spa.eye(n)</div>
<div class="line">    P = spa.coo_matrix(P)</div>
<div class="line">    q = np.random.randn(n)</div>
<div class="line">    A = spa.random(m, n, density=0.15, data_rvs=np.random.randn, format=<span class="stringliteral">&quot;csc&quot;</span>)</div>
<div class="line">    v = np.random.randn(n)  <span class="comment"># Fictitious solution</span></div>
<div class="line">    delta = np.random.rand(m)  <span class="comment"># To get inequality</span></div>
<div class="line">    u = A @ v</div>
<div class="line">    l = -1.0e20 * np.ones(m)</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> P, q, A[:n_eq, :], u[:n_eq], A[n_in:, :], u[n_in:], l[n_in:]</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment"># load a Qp object using Qp problem dimensions</span></div>
<div class="line">n = 10</div>
<div class="line">n_eq = 2</div>
<div class="line">n_in = 2</div>
<div class="line">H, g, A, b, C, u, l = generate_mixed_qp(n)</div>
<div class="line"><span class="comment"># solve the problem using the sparse backend</span></div>
<div class="line"><span class="comment"># and suppose you want to change the accuracy to 1.E-9 and rho initial value to 1.E-7</span></div>
<div class="line">results = proxsuite.qp.dense.solve(</div>
<div class="line">    H=H, g=g, A=A, b=b, C=C, u=u, l=l, rho=1.0e-7, eps_abs=1.0e-9</div>
<div class="line">)</div>
<div class="line"><span class="comment"># Note that in python the order does not matter for rho and eps_abs</span></div>
</div><!-- fragment -->   </td></tr>
</table>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.3-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3 </li>
  </ul>
</div>
</body>
</html>
